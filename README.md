# JNITest
通过CMake方式生成动态库so文件

**简介**
Java JNI的本意是Java Native Interface(Java本地接口)，它是为了方便Java调用C、C++等本地代码所封装的一层接口。通过Java JNI，用户可以调用用C、C++所编写的本地代码
NDK是Android所提供的一个工具集合，通过NDK可以在Android中更加方便地通过JNI来访问本地代码。</br>
**优势**
1.提高代码的安全性。由于so库反编译比较困难，因为NDK提高了Android程序的安全性。</br>
2.可以很方便地使用目前已有的C/C++开源库</br>
3.便于平台间的移植。</br>
4.提高程序在某些特定情形下的执行效率，但是并不能提升Android程序性能</br>

**注**：JNI和NDK开发所用到的动态库的格式是以.so为后缀的文件，JNI和NDK主要用于底层和嵌入式开发，在Android应用层开发中使用比较少。</br>

**JNI开发流程**</br>
**1.在Android Studio配置NDK环境**</br>
打开SDKManager-tools下载NDK插件，下载后到SDK Location里面检查里面的NDK路径</br>
**2.在Java中声明native方法**
创建一个类，叫做JNITest.java
```
package com.qinkl;
public class JNITest{
    static{
        System.loadLibrary("jni-test");
    }

    public static void main(String args[]){
        JNITest jniTest = new JNITest();
        System.out.println(jniTest.jniGet());
        jniTest.jniSet("hello world");
    }

    public native String jniGet();
    public native void jniSet(String str);

}
```

可以看到上面的代码中，声明了两个native方法:get和set(String),这两个就是需要在JNI中实现的方法。在JniTest的头部有一个加载动态库的静态代码块，其中jni-test是so库的标识，so库完整的名称为libjni-test.so，这是加载so库的规范</br>
**3.编译Java源文件得到class文件，然后通过javah命令导出JNI的头文件**</br>
进入cmd，(cd /d 任意目录),选择进入项目文件目录，具体的命令为
```
javac com/qinkl/JNITest.java
javah com.qinkl.JNITest
```
JDK10以前用:javah com.qinkl.JNITest</br>
JDK10以后是没有提供javah的，要用javac代替javah命令：进入cmd,切换到文件所在的根目录,执行命令javac -encoding utf8 -h . JNITest.java</br>

在当前目录下，会产生com_qinkl_JNITest.h的头文件，它是上述命令生成的，内容如下:
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_qinkl_JNITest */

#ifndef _Included_com_qinkl_JNITest
#define _Included_com_qinkl_JNITest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_qinkl_JNITest
 * Method:    jniGet
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_qinkl_JNITest_jniGet
  (JNIEnv *, jobject);

/*
 * Class:     com_qinkl_JNITest
 * Method:    jniSet
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_com_qinkl_JNITest_jniSet
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
```
**说明**</br>
JNIEnv*：表示一个指向JNI环境的指针，可以通过它来访问JNI提供的接口方法</br>
jobect：表示Java对象中的this</br>
JNIEXPORT和JNICALL：他们是JNI中所定义的宏，可以在JNI.h这个头文件中查找到</br>
**4.实现JNI方法**</br>
JNI方法是指Java中声明的native方法，这里可以选择用c++和c来实现。</br>
首先，在工程的主目录下创建一个名为jni的子目录，把之前生成的头文件com_qinkl_JNITest复制进来，接着创建test.cpp文件,内容如下:
```
#include "com_qinkl_JNITest.h"

JNIEXPORT jstring JNICALL Java_com_qinkl_JNITest_jniGet(JNIEnv *env,jobject thiz){
    printf("invoke get in c++\n");
    return (*env)->NewStringUTF(env,"Hello from JNI!");
}

JNIEXPORT void JNICALL Java_com_qinkl_JNITest_jniSet(JNIEnv *env,jobject thiz,jstring string){
    printf("invoke set in c++\n");
    char* str = (char*)(*env)->GetStringUTFChars(env,string,NULL);
    printf("%s\n",str);
    (*env)->ReleaseStringUTFChars(env,string,str);
}
```
**5.生成so库**</br>
在gradle3.0以前生成的方式是，在根目录gradle.properties下面加上：
```
android.useDeprecatedNdk=true
```
然后在项目build.gradle的defaultConfig节点下,添加代码:
```
ndk{
    moduleName "jni-test"//指定生成的so文件名
    abiFilters "armeabi","armeabi-v7a","x86"//CPU的类型
}
```
这两步就可以运行生成so库了</br>
但如果在gradle 3.0之后，已经不支持这样的生成方式了，会报错，内容如下
```
Error: Flag android.useDeprecatedNdk is no longer supported and will be removed in the next version of Android Studio. 
```
**在gradle3.0以上的构建方式:**</br>
**1.首先先到SDKManager->SDK Tools，下载CMake和LLDB**</br>
**2.在项目build.gradle的defaultConfig节点下，添加代码:**</br>
```
externalNativeBuild{
    cmake{
        cppFlags ""
        //生成多个版本的so库
        abiFilters 'armeabi-v7a','arm64-v8a'
    }
}
```
**3.在项目build.gradle的android节点下,添加代码**</br>
```
externalNativeBuild{
    cmake{
        path "CMakeLists.txt"//编译后so文件的名字
    }
}
```
**4.点击build构建一下，可能会出现一下问题:**</br>
```
executing external native build for cmake
```
将gradle的版本3.1.2改成3.2.1，我这边就解决了，再点击build构建一下，就可以在app/build/cmake/debug/obj路径下看到生成的so库了，大功告成!






